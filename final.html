<!DOCTYPE html>
<html lang="hi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<title>Flying Game</title>
<style>
  :root {
    --control-size: 42px;
    --control-gap: 50px;
    --ui-bg: rgba(255,255,255,0.06);
  }
  html,body{
    margin:0;padding:0;height:100%;overflow:hidden;background:#000;
    font-family: "Segoe UI", Roboto, Arial, sans-serif;
    -webkit-tap-highlight-color: transparent;
  }

  /* Canvas fills viewport (we handle DPR for crispness) */
  #gameCanvas{
    display:block;
    width:100vw;
    height:100vh;
    background:#87ceeb;
    touch-action: none;
  }

  /* Top UI area for file inputs - translucent bar */
  #topBar{
    position: fixed;
    top: 8px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 40;
    display: flex;
    gap: 8px;
    padding: 6px;
    border-radius: 10px;
    backdrop-filter: blur(0px);
    background: rgba(0,0,0,0.30);
    border: 0px solid rgba(255,255,255,0.06);
  }

  .file-label {
    cursor: pointer;
    padding: 6px 10px;
    font-size: 14px;
    color:blue;
    border-radius: 12px;
    background: rgba(255,255,255,0.08);
    border: 1px solid rgba(255,255,255,0.30);
    display:flex;align-items:center;gap:6px;
  }
  .file-label:hover { transform: translateY(-8px); transition:0.20s; }

  .hidden-file { display:none; }

  /* Score & Message */
  #scoreDisplay {
    position: fixed;
    top: 12px;
    right: 12px;
    z-index: 45;
    color: red;
    font-weight: 700;
    font-size: 18px;
    text-shadow: 0 4px 8px rgba(0,0,0,0.6);
    background: rgba(0,0,0,0.25);
    padding: 8px 12px;
    border-radius: 20px;
    backdrop-filter: blur(0px);
    border:2px solid rgba(255,240,205,0.04);
  }

  #message {
    position: fixed;
    left: 50%;
    transform: translateX(-50%);
    top: 44%;
    z-index: 42;
    color: #fff;
    font-size: 20px;
    font-weight:600;
    padding: 6px 12px;
    background: rgba(0,0,0,0.32);
    border-radius: 8px;
    backdrop-filter: blur(0px);
    text-shadow: 0 3px 8px rgba(0,0,0,0.6);
  }

  /* Transparent floating controls (mobile) */
  #mobileControls {
    position: fixed;
    bottom: 3vh;
    left: 50%;
    transform: translateX(-50%);
    display:flex;
    gap: var(--control-gap);
    z-index: 50;
    pointer-events: none; /* allow per-button pointer-events */
  }

  .control-btn {
    pointer-events: auto;
    width: var(--control-size);
    height: var(--control-size);
    border-radius: 50%;
    display:flex;
    align-items:center;
    justify-content:center;
    font-size: 26px;
    color: #fff;
    background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
    border: 2px solid rgba(255,255,255,0.12);
    box-shadow: 0 8px 18px rgba(0,0,0,0.5), inset 0 -4px 12px rgba(255,255,255,0.02);
    backdrop-filter: blur(0px);
    transition: transform 0.12s ease, box-shadow 0.12s;
    user-select:none;
    -webkit-user-select:none;
  }
  .control-btn:active { transform: scale(0.92); box-shadow: 0 6px 14px rgba(0,0,0,0.6); }
  .control-btn.small { width:56px; height:56px; font-size:20px; }

  /* Small helper for desktop hints */
  #hint {
    position: fixed;
    left: 12px;
    bottom: 12px;
    color:#fff; font-size:13px; z-index:40;
    background: rgba(0,0,0,0.25); padding:6px 8px; border-radius:8px;
    border:1px solid rgba(255,255,255,0.04);
    backdrop-filter: blur(0px);
  }

  /* Responsive tweaks */
  @media (min-width:900px){
    #mobileControls { bottom: 24px; gap: 18px; }
    .control-btn { width:64px; height:64px; font-size:24px; }
  }
/* Footer styling */
#footer {
  position: fixed;
  bottom: 8px;
  right: 12px;
  color: rgba(255,255,255,0.85);
  font-size: 15px;
  font-weight: 600;
  letter-spacing: 0.5px;
  font-family: "Segoe UI", sans-serif;
  text-shadow: 0 4px 8px rgba(0,0,0,0.8);
  z-index: 60;
  user-select: none;
}
/* Footer scrolling text */
#footer {
  position: fixed;
  bottom: 8px;
  left: 0;
  width: 100%;
  overflow: hidden;
  white-space: nowrap;
  z-index: 60;
  pointer-events: none;
}

#footer span {
  display: inline-block;
  color: rgba(255,255,255,0.85);
  font-size: 16px;
  font-weight: 600;
  font-family: "Segoe UI", sans-serif;
  text-shadow: 0 2px 6px rgba(0,0,0,0.6);
  animation: scrollText 20s linear infinite; /* ‡§ó‡§§‡§ø ‡§¨‡§¶‡§≤‡•á‡§Ç */
}

@keyframes scrollText {
  0%   { transform: translateX(-20%); }
  50%  { transform: translateX(90vw); } /* ‡§∏‡•ç‡§ï‡•ç‡§∞‡•Ä‡§® ‡§ï‡•Ä ‡§ö‡•å‡§°‡§º‡§æ‡§à ‡§ï‡§æ 40% */
  100% { transform: translateX(-20%); }
}


</style>
</head>
<body>

<canvas id="gameCanvas"></canvas>

<!-- Top bar: file upload options -->
<div id="topBar">
  <label class="file-label" title="Flying Object (player)">
    üöÄ Flying Object
    <input id="playerImageInput" class="hidden-file" type="file" accept="image/*">
  </label>
  <label class="file-label" title="Obstacle image">
    üß± Obstacle
    <input id="obstacleImageInput" class="hidden-file" type="file" accept="image/*">
  </label>
  <label class="file-label" title="Background image">
    üñºÔ∏è Background
    <input id="bgImageInput" class="hidden-file" type="file" accept="image/*">
  </label>
  <label class="file-label" title="Background music">
    üé∂ Music
    <input id="bgMusicInput" class="hidden-file" type="file" accept="audio/*">
  </label>
  <label class="file-label" title="Game Over sound">
    üîî Game Over
    <input id="gameOverSoundInput" class="hidden-file" type="file" accept="audio/*">
  </label>
  <label class="file-label" title="Collision sound">
    üí• Collision
    <input id="collisionSoundInput" class="hidden-file" type="file" accept="audio/*">
  </label>
</div>

<div id="scoreDisplay">Score: 0</div>
<div id="message">Ready! Tap or Click to Start.</div>

<!-- Transparent floating controls -->
<div id="mobileControls">
  <div id="btnUp" class="control-btn" aria-label="Up">‚¨ÜÔ∏è</div>
  <div id="btnDown" class="control-btn" aria-label="Down">‚¨áÔ∏è</div>
</div>

<div id="hint">Desktop: ‚Üë ‚Üì or Click</div>

<!-- Audio elements (we'll set src via JS when user uploads) -->
<audio id="backgroundMusic" loop></audio>
<audio id="gameOverSound"></audio>
<audio id="collisionSound"></audio>

<script>
/* ============================
   Core: responsive & DPR canvas
   ============================ */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

function resizeCanvasToDisplaySize() {
  // Fill viewport and account DPR for crisp rendering
  const vw = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0);
  const vh = Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0);
  const ratio = window.devicePixelRatio || 1;
  canvas.style.width = vw + "px";
  canvas.style.height = vh + "px";
  canvas.width = Math.round(vw * ratio);
  canvas.height = Math.round(vh * ratio);
  ctx.setTransform(ratio, 0, 0, ratio, 0, 0); // scale drawing operations
}
window.addEventListener('resize', resizeCanvasToDisplaySize);
window.addEventListener('orientationchange', () => { setTimeout(resizeCanvasToDisplaySize, 150); });
resizeCanvasToDisplaySize();

/* Try to lock landscape (best-effort) */
if (screen.orientation && screen.orientation.lock) {
  screen.orientation.lock('landscape').catch(()=>{/*ignore*/});
}

/* ============================
   Assets / Elements
   ============================ */
const playerImageInput = document.getElementById('playerImageInput');
const obstacleImageInput = document.getElementById('obstacleImageInput');
const bgImageInput = document.getElementById('bgImageInput');
const bgMusicInput = document.getElementById('bgMusicInput');
const gameOverSoundInput = document.getElementById('gameOverSoundInput');
const collisionSoundInput = document.getElementById('collisionSoundInput');

const backgroundMusic = document.getElementById('backgroundMusic');
const gameOverSound = document.getElementById('gameOverSound');
const collisionSound = document.getElementById('collisionSound');

let playerImage = null, obstacleImage = null, backgroundImage = null;

/* helper to load file -> dataURL */
function loadFileAsDataURL(file, callback){
  if(!file) return;
  const reader = new FileReader();
  reader.onload = e => callback(e.target.result);
  reader.onerror = () => console.warn("File read error");
  reader.readAsDataURL(file);
}

/* wire input events */
playerImageInput.addEventListener('change', e => {
  if(e.target.files[0]) loadFileAsDataURL(e.target.files[0], src => {
    const img = new Image(); img.onload = ()=> playerImage = img; img.src = src;
  });
});
obstacleImageInput.addEventListener('change', e => {
  if(e.target.files[0]) loadFileAsDataURL(e.target.files[0], src => {
    const img = new Image(); img.onload = ()=> obstacleImage = img; img.src = src;
  });
});
bgImageInput.addEventListener('change', e => {
  if(e.target.files[0]) loadFileAsDataURL(e.target.files[0], src => {
    const img = new Image(); img.onload = ()=> backgroundImage = img; img.src = src;
  });
});
bgMusicInput.addEventListener('change', e => {
  if(e.target.files[0]) loadFileAsDataURL(e.target.files[0], src => {
    backgroundMusic.src = src; backgroundMusic.load();
  });
});
gameOverSoundInput.addEventListener('change', e => {
  if(e.target.files[0]) loadFileAsDataURL(e.target.files[0], src => {
    gameOverSound.src = src; gameOverSound.load();
  });
});
collisionSoundInput.addEventListener('change', e => {
  if(e.target.files[0]) loadFileAsDataURL(e.target.files[0], src => {
    collisionSound.src = src; collisionSound.load();
  });
});

/* ============================
   Game settings & state
   ============================ */
const SCORE_KEY = "flyingGameScore";
const BEST_KEY = "flyingGameBest";

const PLAYER_SETTINGS = { x: 80, width: 92, height: 48, color: "#FFD700", jumpPower: -8, gravity: 0.38 };
const OBSTACLE_SETTINGS = { width: 90, gap: 230, speed: 4.0 };
const COLLISION_OVERLAP_THRESHOLD = 0.40; // 40% overlap rule

let player = { x: PLAYER_SETTINGS.x, y: 100, width: PLAYER_SETTINGS.width, height: PLAYER_SETTINGS.height, vel: 0 };
let obstacles = [];
let score = Number(localStorage.getItem(SCORE_KEY)) || 0;
let best = Number(localStorage.getItem(BEST_KEY)) || 0;
let running = false;
let lastTime = 0, obstacleTimer = 0;
let isDestroying = false, imageFragments = [], destroyStart = 0, destroyDuration = 1200;

/* initialize UI values */
document.getElementById('scoreDisplay').textContent = `Score: ${score}`;

/* ============================
   Utility drawing helpers
   ============================ */
function drawBackground(){
  // base color
  ctx.fillStyle = '#87ceeb';
  ctx.fillRect(0,0,canvas.width,canvas.height);

  // draw bg image contain/center if available
  if (backgroundImage && backgroundImage.naturalWidth) {
    const vw = canvas.width / (window.devicePixelRatio||1);
    const vh = canvas.height / (window.devicePixelRatio||1);
    const iw = backgroundImage.naturalWidth, ih = backgroundImage.naturalHeight;
    const ratio = Math.min(vw/iw, vh/ih);
    const w = iw*ratio, h = ih*ratio;
    const x = (vw - w)/2, y = (vh - h)/2;
    ctx.drawImage(backgroundImage, x, y, w, h);
  } else {
    // some clouds / simple decoration
    const vw = canvas.width/(window.devicePixelRatio||1);
    for(let i=0;i<6;i++){
      ctx.fillStyle = "rgba(255,255,255,0.12)";
      ctx.beginPath();
      ctx.ellipse( (i*127)%vw + 80, 60 + (i%3)*20, 80, 30, 0, 0, Math.PI*2 );
      ctx.fill();
    }
  }
}

function drawPlayer(){
  if (isDestroying) {
    drawDestruction();
    return;
  }
  if (playerImage && playerImage.naturalWidth) {
    // keep aspect ratio
    const aspect = playerImage.naturalWidth / playerImage.naturalHeight;
    let w = player.width, h = player.height;
    if (w/h > aspect) w = h*aspect; else h = w/aspect;
    ctx.drawImage(playerImage, player.x, player.y, w, h);
  } else {
    ctx.fillStyle = PLAYER_SETTINGS.color;
    ctx.fillRect(player.x, player.y, player.width, player.height);
    // simple wing
    ctx.fillStyle = "rgba(0,0,0,0.08)";
    ctx.fillRect(player.x+6, player.y+player.height*0.15, player.width*0.2, player.height*0.7);
  }
}

function drawObstacles(){
  ctx.fillStyle = "#8B0000";
  obstacles.forEach(obs=>{
    if (obstacleImage && obstacleImage.naturalWidth) {
      // draw image stretched
      ctx.save();
      ctx.translate(obs.x + OBSTACLE_SETTINGS.width/2, obs.y + obs.h/2);
      if (obs.y !== 0) {
        // bottom obstacle flip
        ctx.rotate(Math.PI);
      }
      ctx.drawImage(obstacleImage, -OBSTACLE_SETTINGS.width/2, -obs.h/2, OBSTACLE_SETTINGS.width, obs.h);
      ctx.restore();
    } else {
      ctx.fillRect(obs.x, obs.y, OBSTACLE_SETTINGS.width, obs.h);
    }
  });
}

/* ============================
   Obstacle creation & update
   ============================ */
function createObstaclePair(){
  const vw = canvas.width / (window.devicePixelRatio||1);
  const vh = canvas.height / (window.devicePixelRatio||1);
  const minTop = 50;
  const maxTop = vh - OBSTACLE_SETTINGS.gap - minTop;
  const topH = Math.max(minTop, Math.random() * (maxTop - minTop) + minTop);
  const x = vw + 10;
  obstacles.push({ x, y:0, h: topH, passed: false });
  obstacles.push({ x, y: topH + OBSTACLE_SETTINGS.gap, h: vh - topH - OBSTACLE_SETTINGS.gap, passed: false });
}

function updateObstacles(dt){
  const vw = canvas.width / (window.devicePixelRatio||1);
  for (let i = obstacles.length-1; i>=0; i--){
    obstacles[i].x -= OBSTACLE_SETTINGS.speed * (dt/16.67);
    if (!obstacles[i].passed && obstacles[i].x + OBSTACLE_SETTINGS.width < player.x) {
      obstacles[i].passed = true;
      // Only increment score when the top obstacle passes (we mark pairs by their index parity)
      if (i % 2 === 0) {
        score++;
        document.getElementById('scoreDisplay').textContent = `Score: ${score}`;
        localStorage.setItem(SCORE_KEY, score);
        if (score > best) { best = score; localStorage.setItem(BEST_KEY, best); }
      }
    }
    if (obstacles[i].x + OBSTACLE_SETTINGS.width < -50) {
      obstacles.splice(i,1);
    }
  }
}

/* ============================
   Collision detection (40% overlap)
   ============================ */
function checkCollision() {
  if (isDestroying) return false;
  const px = player.x, py = player.y, pw = player.width, ph = player.height;
  const playerArea = pw * ph;
  for (let obs of obstacles) {
    const ox = obs.x, oy = obs.y, ow = OBSTACLE_SETTINGS.width, oh = obs.h;
    if (px < ox + ow && px + pw > ox && py < oy + oh && py + ph > oy) {
      const overlapX = Math.max(0, Math.min(px+pw, ox+ow) - Math.max(px, ox));
      const overlapY = Math.max(0, Math.min(py+ph, oy+oh) - Math.max(py, oy));
      const overlapArea = overlapX * overlapY;
      if (overlapArea > COLLISION_OVERLAP_THRESHOLD * playerArea) {
        // start image destruction animation if playerImage is present, else immediate game over
        if (playerImage && playerImage.naturalWidth) startDestruction();
        else triggerGameOver('collision');
        return true;
      }
    }
  }
  return false;
}

/* ============================
   Player update & controls
   ============================ */
function updatePlayer(dt){
  if (isDestroying) return;
  player.vel += PLAYER_SETTINGS.gravity * (dt/16.67);
  player.y += player.vel * (dt/16.67);
  // boundary checks
  const vh = canvas.height / (window.devicePixelRatio||1);
  if (player.y < 0) { player.y = 0; player.vel = 0; triggerGameOver('boundary'); }
  if (player.y + player.height > vh) { triggerGameOver('boundary'); }
}

function flyUp(){ if (running && !isDestroying) player.vel = PLAYER_SETTINGS.jumpPower; }
function flyDown(){ if (running && !isDestroying) player.vel = -PLAYER_SETTINGS.jumpPower/2; }

/* ============================
   Destruction animation (image fragments)
   ============================ */
function startDestruction() {
  isDestroying = true;
  imageFragments = [];
  destroyStart = performance.now();
  const cols = 4, rows = 3;
  const fw = player.width/cols, fh = player.height/rows;
  const srcW = playerImage.naturalWidth/cols, srcH = playerImage.naturalHeight/rows;
  for (let r=0;r<rows;r++){
    for (let c=0;c<cols;c++){
      imageFragments.push({
        x: player.x + c*fw,
        y: player.y + r*fh,
        w: fw, h: fh,
        sx: c*srcW, sy: r*srcH, sw: srcW, sh: srcH,
        vx: (Math.random()-0.5)*6, vy: (Math.random()-1.5)*6,
        rotation: 0, rotSpeed: (Math.random()-0.5)*0.28,
        alpha: 1, scale:1
      });
    }
  }
  // play collision sound
  collisionSound.play().catch(()=>{});
}

function drawDestruction() {
  const now = performance.now();
  imageFragments.forEach((frag, idx) => {
    frag.x += frag.vx;
    frag.y += frag.vy;
    frag.vy += 0.18;
    frag.rotation += frag.rotSpeed;
    frag.alpha -= 0.01;
    frag.scale = Math.max(0, frag.scale - 0.006);
    ctx.save();
    ctx.globalAlpha = frag.alpha;
    ctx.translate(frag.x + frag.w/2, frag.y + frag.h/2);
    ctx.rotate(frag.rotation);
    ctx.scale(frag.scale, frag.scale);
    ctx.drawImage(playerImage, frag.sx, frag.sy, frag.sw, frag.sh, -frag.w/2, -frag.h/2, frag.w, frag.h);
    ctx.restore();
  });
  // remove fully faded
  imageFragments = imageFragments.filter(f => f.alpha > 0.02 && f.scale > 0.02);
  if (performance.now() - destroyStart > destroyDuration && imageFragments.length === 0) {
    isDestroying = false;
    triggerGameOver('collision');
  }
}

/* ============================
   Game loop & lifecycle
   ============================ */
function triggerGameOver(type){
  if (!running) return;
  running = false;
  // stop music
  try { backgroundMusic.pause(); backgroundMusic.currentTime = 0; } catch(e){}
  // play game over sound if available
  if (type === 'boundary' || type === 'collision') {
    gameOverSound.play().catch(()=>{});
  }
  // UI
  document.getElementById('message').textContent = `GAME OVER! Score: ${score}. Tap to Restart.`;
  // update best
  if (score > best) { best = score; localStorage.setItem(BEST_KEY, best); }
  // set canvas to wait for restart click/tap
}

function startGame(){
  // reset
  const vh = canvas.height / (window.devicePixelRatio||1);
  const vw = canvas.width / (window.devicePixelRatio||1);
  player.x = PLAYER_SETTINGS.x;
  player.width = PLAYER_SETTINGS.width;
  player.height = PLAYER_SETTINGS.height;
  player.y = Math.max(60, vh/2 - player.height/2);
  player.vel = 0;
  obstacles = [];
  score = Number(localStorage.getItem(SCORE_KEY)) || 0;
  document.getElementById('scoreDisplay').textContent = `Score: ${score}`;
  document.getElementById('message').textContent = "";
  running = true;
  lastTime = performance.now();
  obstacleTimer = 0;
  isDestroying = false;
  imageFragments = [];
  // play background music if present
  backgroundMusic.play().catch(()=>{/*blocked until user interacts with page in some browsers */});
  requestAnimationFrame(gameLoop);
}

function gameLoop(now){
  if (!running) return;
  const dt = now - lastTime || 16.67;
  lastTime = now;
  obstacleTimer += dt;
  if (obstacleTimer > 2000) { createObstaclePair(); obstacleTimer = 0; }
  updatePlayer(dt);
  updateObstacles(dt);
  // render
  drawBackground();
  drawObstacles();
  drawPlayer();
  // collision check AFTER drawing to allow destruction animation
  if (checkCollision()) {
    // if destruction started, continue animating until destruction finishes
    if (isDestroying) {
      requestAnimationFrame(gameLoop);
      return;
    }
  }
  requestAnimationFrame(gameLoop);
}

/* ============================
   Controls: mouse/keyboard/touch/buttons
   ============================ */
document.addEventListener('keydown', e => {
  if (e.key === "ArrowUp" || e.key === "w") flyUp();
  if (e.key === "ArrowDown" || e.key === "s") flyDown();
  if (e.key === " " && !running) startGame();
});
canvas.addEventListener('mousedown', e => {
  if (!running) startGame(); else flyUp();
});
canvas.addEventListener('touchstart', e => {
  e.preventDefault();
  if (!running) startGame(); else flyUp();
}, {passive:false});

document.getElementById('btnUp').addEventListener('touchstart', e=>{ e.preventDefault(); flyUp(); }, {passive:false});
document.getElementById('btnDown').addEventListener('touchstart', e=>{ e.preventDefault(); flyDown(); }, {passive:false});
document.getElementById('btnUp').addEventListener('mousedown', e=>{ flyUp(); });
document.getElementById('btnDown').addEventListener('mousedown', e=>{ flyDown(); });

/* Also support pointer events so desktop + stylus works nicely */
document.getElementById('btnUp').addEventListener('pointerdown', e=>{ e.preventDefault(); flyUp(); });
document.getElementById('btnDown').addEventListener('pointerdown', e=>{ e.preventDefault(); flyDown(); });

/* Start on first user click if score exists ‚Äî message instructs user */
document.getElementById('message').addEventListener('click', ()=> { if (!running) startGame(); });

/* ============================
   Score reset helper (long-press top bar)
   ============================ */
let topBar = document.getElementById('topBar');
let longPressTimer = null;
topBar.addEventListener('touchstart', () => {
  longPressTimer = setTimeout(()=>{ localStorage.removeItem(SCORE_KEY); localStorage.removeItem(BEST_KEY); score = 0; best = 0; document.getElementById('scoreDisplay').textContent = `Score: ${score}`; alert('Scores cleared'); }, 1100);
});
topBar.addEventListener('touchend', ()=>{ clearTimeout(longPressTimer); });
topBar.addEventListener('mousedown', () => {
  longPressTimer = setTimeout(()=>{ localStorage.removeItem(SCORE_KEY); localStorage.removeItem(BEST_KEY); score = 0; best = 0; document.getElementById('scoreDisplay').textContent = `Score: ${score}`; alert('Scores cleared'); }, 1100);
});
topBar.addEventListener('mouseup', ()=>{ clearTimeout(longPressTimer); });

/* ============================
   Initialization
   ============================ */
(function init(){
  resizeCanvasToDisplaySize();
  // initialize player vertical pos according to viewport
  const vh = canvas.height / (window.devicePixelRatio||1);
  player.y = Math.max(60, vh/2 - player.height/2);
  document.getElementById('scoreDisplay').textContent = `Score: ${score}`;
  // If background music previously set, it will play when user starts game
  // Small UX hint: show best score in console (optional)
  if (best) console.log("Best score:", best);
/* ============================
   Auto-hide TopBar safely + Glow Fade Animation
   ============================ */
const topBar = document.getElementById('topBar');
let hideTimer = null;

// glow effect CSS
const glowStyle = document.createElement("style");
glowStyle.textContent = `
@keyframes glowIn {
  0% { box-shadow: 0 0 0px rgba(255,255,255,0.0); transform: translateY(-6px); }
  50% { box-shadow: 0 0 14px rgba(255,255,255,0.4); transform: translateY(0); }
  100% { box-shadow: 0 0 0px rgba(255,255,255,0.0); }
}
#topBar.glow {
  animation: glowIn 1.2s ease;
}
`;
document.head.appendChild(glowStyle);

// ‡§ï‡•á‡§µ‡§≤ opacity ‡§∏‡•á hide ‡§ï‡§∞‡•á‡§Ç, display:none ‡§® ‡§ï‡§∞‡•á‡§Ç
function autoHideTopBar() {
  hideTimer = setTimeout(() => {
    topBar.style.transition = "opacity 0.8s ease";
    topBar.style.opacity = "0";
    topBar.style.pointerEvents = "none"; // ‡§ï‡•ç‡§≤‡§ø‡§ï ‡§∞‡•ã‡§ï‡•á‡§Ç ‡§™‡§∞ ‡§ó‡•á‡§Æ ‡§ö‡§≤‡§§‡§æ ‡§∞‡§π‡•á
  }, 10000);
}

// show function
function showTopBar() {
  clearTimeout(hideTimer);
  topBar.style.pointerEvents = "auto";
  topBar.style.transition = "opacity 0.4s ease";
  topBar.style.opacity = "1";
  topBar.classList.add('glow');
  setTimeout(() => topBar.classList.remove('glow'), 1200);
  autoHideTopBar();
}

// ‡§ú‡§¨ ‡§Æ‡§æ‡§â‡§∏ ‡§Ø‡§æ ‡§ü‡§ö ‡§ä‡§™‡§∞ ‡§ú‡§æ‡§è
document.addEventListener('mousemove', e => {
  if (e.clientY < 08) showTopBar();
});
document.addEventListener('touchstart', e => {
  if (e.touches[0].clientY < 100) showTopBar();
});

// ‡§™‡•ç‡§∞‡§æ‡§∞‡§Ç‡§≠ ‡§Æ‡•á‡§Ç hide ‡§∂‡•Å‡§∞‡•Ç ‡§ï‡§∞‡•á‡§Ç
autoHideTopBar();

/* ============================
   Local Save & Restore User Settings
   ============================ */
const SETTINGS_KEY = "flyingGameUserSettings";

// Load saved settings from localStorage
function loadUserSettings() {
  const saved = localStorage.getItem(SETTINGS_KEY);
  if (!saved) return;
  try {
    const data = JSON.parse(saved);

    if (data.playerImage) {
      const img = new Image();
      img.onload = () => (playerImage = img);
      img.src = data.playerImage;
    }
    if (data.obstacleImage) {
      const img = new Image();
      img.onload = () => (obstacleImage = img);
      img.src = data.obstacleImage;
    }
    if (data.backgroundImage) {
      const img = new Image();
      img.onload = () => (backgroundImage = img);
      img.src = data.backgroundImage;
    }
    if (data.bgMusic) {
      backgroundMusic.src = data.bgMusic;
      backgroundMusic.load();
    }
    if (data.gameOverSound) {
      gameOverSound.src = data.gameOverSound;
      gameOverSound.load();
    }
    if (data.collisionSound) {
      collisionSound.src = data.collisionSound;
      collisionSound.load();
    }
    console.log("üéµ User settings restored from localStorage.");
  } catch (err) {
    console.warn("Failed to restore settings:", err);
  }
}

// Save settings whenever a file changes
function saveUserSettings() {
  const settings = {
    playerImage: playerImage ? playerImage.src : null,
    obstacleImage: obstacleImage ? obstacleImage.src : null,
    backgroundImage: backgroundImage ? backgroundImage.src : null,
    bgMusic: backgroundMusic.src || null,
    gameOverSound: gameOverSound.src || null,
    collisionSound: collisionSound.src || null,
  };
  localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
  console.log("üíæ Settings saved locally.");
}

// Attach file change listeners to auto-save
[playerImageInput, obstacleImageInput, bgImageInput, bgMusicInput, gameOverSoundInput, collisionSoundInput].forEach(input => {
  input.addEventListener("change", () => {
    // wait 1s for file load then save
    setTimeout(saveUserSettings, 1000);
  });
});

// Restore when page loads
loadUserSettings();


})();

</script>
<!-- Footer text -->
<div id="footer">¬© Shiv Computer</div>
<!-- Footer text -->
<div id="footer"><span>¬© Shiv Computer</span></div>

</body>
</html>
